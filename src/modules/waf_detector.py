"""
WAF Detector - Identifica WAF/CDN e ajusta estratégia de testes
Previne falsos negativos e bloqueios desnecessários
"""

class WAFDetector:
    """Detecta Web Application Firewalls e CDNs."""
    
    WAF_SIGNATURES = {
        'Cloudflare': {
            'headers': ['cf-ray', 'cf-request-id', '__cfduid'],
            'cookies': ['__cfduid', '__cflb'],
            'html_patterns': ['cloudflare', 'attention required'],
        },
        'AWS WAF': {
            'headers': ['x-amz-cf-id', 'x-amzn-requestid', 'x-amzn-trace-id'],
            'cookies': [],
            'html_patterns': ['request blocked'],
        },
        'Akamai': {
            'headers': ['akamai-ghost', 'x-akamai-transformed'],
            'cookies': ['ak_bmsc'],
            'html_patterns': [],
        },
        'Sucuri': {
            'headers': ['x-sucuri-id', 'x-sucuri-cache'],
            'cookies': ['sucuri-'],
            'html_patterns': ['sucuri website firewall'],
        },
        'ModSecurity': {
            'headers': ['mod_security', 'NAXSI'],
            'cookies': [],
            'html_patterns': ['mod_security', 'this error was generated by mod_security'],
        },
        'Imperva Incapsula': {
            'headers': ['x-cdn'],
            'cookies': ['incap_ses', 'visid_incap'],
            'html_patterns': ['incapsula'],
        },
        'F5 BIG-IP': {
            'headers': ['x-wa-info'],
            'cookies': ['BIGipServer', 'TS'],
            'html_patterns': [],
        },
    }
    
    def __init__(self):
        self.detected_waf = None
        self.detection_confidence = 0.0
    
    def detect(self, response):
        """
        Detecta WAF/CDN baseado em resposta HTTP.
        
        Args:
            response: requests.Response object
        
        Returns:
            dict: {
                'waf_name': str or None,
                'confidence': float 0-1,
                'indicators': list of detected indicators
            }
        """
        headers = {k.lower(): v.lower() for k, v in response.headers.items()}
        cookies = response.cookies
        body = response.text.lower() if hasattr(response, 'text') else ''
        
        best_match = None
        best_score = 0
        best_indicators = []
        
        for waf_name, signatures in self.WAF_SIGNATURES.items():
            indicators = []
            score = 0
            
            # Check headers
            for sig in signatures['headers']:
                if any(sig.lower() in h for h in headers.keys()) or \
                   any(sig.lower() in v for v in headers.values()):
                    indicators.append(f"Header: {sig}")
                    score += 0.4
            
            # Check cookies
            for sig in signatures['cookies']:
                if any(sig.lower() in str(c).lower() for c in cookies):
                    indicators.append(f"Cookie: {sig}")
                    score += 0.3
            
            # Check HTML patterns
            for pattern in signatures['html_patterns']:
                if pattern.lower() in body:
                    indicators.append(f"HTML: {pattern}")
                    score += 0.3
            
            # Normalize score (cap at 1.0)
            score = min(score, 1.0)
            
            if score > best_score:
                best_score = score
                best_match = waf_name
                best_indicators = indicators
        
        # Consider detected if confidence > 50%
        if best_score > 0.5:
            self.detected_waf = best_match
            self.detection_confidence = best_score
        
        return {
            'waf_name': best_match if best_score > 0.5 else None,
            'confidence': best_score,
            'indicators': best_indicators,
        }
    
    def is_waf_detected(self):
        """Retorna True se WAF foi detectado."""
        return self.detected_waf is not None
    
    def get_waf_info(self):
        """
        Retorna informações sobre WAF detectado.
        
        Returns:
            dict: Informações do WAF
        """
        if not self.detected_waf:
            return {
                'detected': False,
                'name': None,
                'recommendation': 'Continue testes normalmente'
            }
        
        return {
            'detected': True,
            'name': self.detected_waf,
            'confidence': f"{int(self.detection_confidence * 100)}%",
            'recommendation': self.get_testing_recommendation(),
        }
    
    def get_testing_recommendation(self):
        """
        Retorna recomendação de teste baseado no WAF.
        
        Returns:
            str: Recomendação
        """
        if not self.detected_waf:
            return 'Testes padrão'
        
        recommendations = {
            'Cloudflare': 'Use delays maiores (2-3s). Cloudflare tem rate limiting agressivo.',
            'AWS WAF': 'Payloads precisam ser mais sutis. AWS WAF detecta patterns comuns.',
            'ModSecurity': 'Evite payloads óbvios. ModSecurity tem regras extensas.',
            'Sucuri': 'Testes conservadores recomendados. Sucuri bloqueia facilmente.',
            'Imperva Incapsula': 'Use técnicas de obfuscação. Imperva é muito sensível.',
            'F5 BIG-IP': 'Testes padrão aceitáveis. F5 foca em performance, não detecção.',
            'Akamai': 'CDN, não WAF. Testes normais aceitáveis.',
        }
        
        return recommendations.get(self.detected_waf, 'Testes com cautela recomendados.')
    
    def should_adjust_payloads(self):
        """
        Retorna True se payloads devem ser ajustados.
        
        Returns:
            bool
        """
        # Ajustar para WAFs conhecidos por bloqueio agressivo
        aggressive_wafs = ['ModSecurity', 'Sucuri', 'Imperva Incapsula', 'AWS WAF']
        return self.detected_waf in aggressive_wafs
    
    def get_adjusted_delay(self, base_delay):
        """
        Retorna delay ajustado baseado no WAF.
        
        Args:
            base_delay: float - Delay base em segundos
        
        Returns:
            float: Delay ajustado
        """
        if not self.detected_waf:
            return base_delay
        
        # Cloudflare precisa de delays maiores
        if self.detected_waf == 'Cloudflare':
            return base_delay * 3
        
        # WAFs agressivos: 2x delay
        if self.should_adjust_payloads():
            return base_delay * 2
        
        return base_delay
