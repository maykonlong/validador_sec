"""
Vulnerability Chainer - Detecta combinações perigosas de vulnerabilidades
Identifica attack chains que elevam severidade e impacto
"""

class VulnerabilityChainer:
    """Detecta chains de vulnerabilidades que criam ataques críticos."""
    
    # Chains perigosos conhecidos
    ATTACK_CHAINS = [
        {
            'id': 'CHAIN-001',
            'name': 'Account Takeover via CORS + XSS',
            'vulnerabilities': ['CORS', 'XSS', 'Cross-Site Scripting'],
            'conditions': {
                'CORS': lambda f: 'Exploitável' in f.get('vulnerability', '') or 'Wildcard' in f.get('details', ''),
                'XSS': lambda f: 'Confirmado' in f.get('vulnerability', '') or f.get('confidence', 0) > 0.7,
            },
            'severity_upgrade': 'Critical',
            'impact': 'Complete account takeover possible. Attacker can steal session tokens via XSS and access victim account from any origin due to CORS misconfiguration.',
            'attack_scenario': [
                '1. Attacker hosts malicious page with XSS payload',
                '2. Victim visits attacker\'s page',
                '3. XSS executes and steals session token',
                '4. CORS allows attacker origin to make authenticated requests',
                '5. Attacker gains full account access',
            ],
            'remediation_priority': 'P0 - Critical',
            'cvss_base': 9.8,
        },
        {
            'id': 'CHAIN-002',
            'name': 'Data Exfiltration via SQLi + SSRF',
            'vulnerabilities': ['SQL Injection', 'SSRF'],
            'conditions': {
                'SQL Injection': lambda f: 'Confirmado' in f.get('vulnerability', ''),
                'SSRF': lambda f: True,  # Qualquer SSRF
            },
            'severity_upgrade': 'Critical',
            'impact': 'Complete database exfiltration to external server. Attacker can dump entire database and send to remote location.',
            'attack_scenario': [
                '1. Exploit SQLi to access database',
                '2. Use SSRF to send data to attacker-controlled server',
                '3. Exfiltrate sensitive data (users, passwords, PII)',
                '4. Bypass network restrictions via SSRF',
            ],
            'remediation_priority': 'P0 - Critical',
            'cvss_base': 9.6,
        },
        {
            'id': 'CHAIN-003',
            'name': 'Credential Harvesting via Open Redirect + XSS',
            'vulnerabilities': ['Open Redirect', 'XSS', 'Cross-Site Scripting'],
            'conditions': {
                'Open Redirect': lambda f: 'Confirmado' in f.get('vulnerability', ''),
                'XSS': lambda f: True,
            },
            'severity_upgrade': 'High',
            'impact': 'Sophisticated phishing attack. Victims trust the legitimate domain but are redirected to attacker-controlled page that steals credentials.',
            'attack_scenario': [
                '1. Create fake login page with XSS payload',
                '2. Use open redirect to send victims from legitimate domain',
                '3. Victims trust domain and enter credentials',
                '4. XSS captures and sends credentials to attacker',
            ],
            'remediation_priority': 'P1 - Urgent',
            'cvss_base': 8.1,
        },
        {
            'id': 'CHAIN-004',
            'name': 'Session Fixation via Clickjacking + XSS',
            'vulnerabilities': ['Clickjacking', 'XSS', 'Cross-Site Scripting'],
            'conditions': {
                'Clickjacking': lambda f: 'Vulnerável' in f.get('status', '') or 'Sem' in f.get('vulnerability', ''),
                'XSS': lambda f: True,
            },
            'severity_upgrade': 'High',
            'impact': 'Force victim to perform actions while session is compromised by XSS.',
            'attack_scenario': [
                '1. Use Clickjacking to trick victim into clicking',
                '2. XSS steals session during the action',
                '3. Attacker gains authenticated session',
            ],
            'remediation_priority': 'P1 - Urgent',
            'cvss_base': 7.5,
        },
        {
            'id': 'CHAIN-005',
            'name': 'Privilege Escalation via SQLi + Weak Auth',
            'vulnerabilities': ['SQL Injection', 'Autenticação', 'Authentication'],
            'conditions': {
                'SQL Injection': lambda f: 'Confirmado' in f.get('vulnerability', ''),
                'Autenticação': lambda f: 'Weak' in f.get('details', '') or 'Fraca' in f.get('details', ''),
            },
            'severity_upgrade': 'Critical',
            'impact': 'Admin account takeover via database manipulation.',
            'attack_scenario': [
                '1. Exploit SQLi to access user table',
                '2. Modify user role to admin',
                '3. Login with weak credentials',
                '4. Full admin access achieved',
            ],
            'remediation_priority': 'P0 - Critical',
            'cvss_base': 9.1,
        },
    ]
    
    def __init__(self):
        self.detected_chains = []
    
    def detect_chains(self, findings):
        """
        Detecta attack chains nos findings.
        
        Args:
            findings: list - Lista de findings
        
        Returns:
            list: Chains detectados
        """
        self.detected_chains = []
        
        for chain_def in self.ATTACK_CHAINS:
            if self._check_chain(chain_def, findings):
                chain_finding = self._create_chain_finding(chain_def, findings)
                self.detected_chains.append(chain_finding)
        
        return self.detected_chains
    
    def _check_chain(self, chain_def, findings):
        """
        Verifica se chain está presente nos findings.
        
        Args:
            chain_def: dict - Definição do chain
            findings: list - Findings
        
        Returns:
            bool: True se chain detectado
        """
        required_vulns = chain_def['vulnerabilities']
        conditions = chain_def.get('conditions', {})
        
        # Para cada vulnerabilidade requerida
        found_vulns = {}
        
        for required_vuln in required_vulns:
            # Buscar finding que contenha essa vuln
            for finding in findings:
                vuln_name = finding.get('vulnerability', '')
                
                # Match parcial (case-insensitive)
                if required_vuln.lower() in vuln_name.lower():
                    # Verificar condições adicionais se existirem
                    condition_func = conditions.get(required_vuln)
                    
                    if condition_func and not condition_func(finding):
                        continue  # Condição não satisfeita
                    
                    found_vulns[required_vuln] = finding
                    break
        
        # Chain detectado se todas as vulns foram encontradas
        return len(found_vulns) >= 2  # Pelo menos 2 vulnerabilidades
    
    def _create_chain_finding(self, chain_def, findings):
        """
        Cria finding do chain detectado.
        
        Returns:
            dict: Finding do chain
        """
        # Coletar findings envolvidos
        involved_findings = []
        for vuln in chain_def['vulnerabilities']:
            for finding in findings:
                if vuln.lower() in finding.get('vulnerability', '').lower():
                    involved_findings.append({
                        'vulnerability': finding.get('vulnerability'),
                        'url': finding.get('url', 'N/A'),
                        'severity': finding.get('severity'),
                    })
                    break
        
        # Criar descrição detalhada
        details = f"""
<strong>ATTACK CHAIN DETECTED: {chain_def['name']}</strong><br><br>

<strong>Chain ID:</strong> {chain_def['id']}<br>
<strong>CVSS Base Score:</strong> {chain_def['cvss_base']}<br>
<strong>Severity Upgrade:</strong> {chain_def['severity_upgrade']}<br><br>

<strong>Impact:</strong><br>
{chain_def['impact']}<br><br>

<strong>Attack Scenario:</strong><br>
{'<br>'.join(chain_def['attack_scenario'])}<br><br>

<strong>Vulnerabilities Involved:</strong><br>
"""
        
        for inv_finding in involved_findings:
            details += f"• {inv_finding['vulnerability']} ({inv_finding['severity']})<br>"
        
        details += f"<br><strong>Remediation Priority:</strong> {chain_def['remediation_priority']}"
        
        return {
            'chain_id': chain_def['id'],
            'chain_name': chain_def['name'],
            'severity': chain_def['severity_upgrade'],
            'cvss_base': chain_def['cvss_base'],
            'impact': chain_def['impact'],
            'attack_scenario': chain_def['attack_scenario'],
            'involved_findings': involved_findings,
            'details': details,
            'remediation_priority': chain_def['remediation_priority'],
        }
    
    def get_chain_count(self):
        """Retorna quantidade de chains detectados."""
        return len(self.detected_chains)
    
    def get_critical_chains(self):
        """Retorna apenas chains críticos."""
        return [
            chain for chain in self.detected_chains
            if chain['severity'] == 'Critical'
        ]
    
    def generate_chain_report(self):
        """
        Gera relatório de chains detectados.
        
        Returns:
            dict: Relatório
        """
        if not self.detected_chains:
            return {
                'total_chains': 0,
                'critical_chains': 0,
                'status': 'No dangerous vulnerability chains detected',
            }
        
        critical_count = len(self.get_critical_chains())
        
        return {
            'total_chains': len(self.detected_chains),
            'critical_chains': critical_count,
            'high_chains': len([c for c in self.detected_chains if c['severity'] == 'High']),
            'chains': self.detected_chains,
            'status': 'CRITICAL - Dangerous attack chains detected!' if critical_count > 0 else 'WARNING - Attack chains detected',
            'recommendation': 'Fix all involved vulnerabilities immediately to break the attack chain.',
        }
